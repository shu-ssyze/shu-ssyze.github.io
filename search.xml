<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ICPC徐州区域赛2019总结]]></title>
    <url>%2F2019%2F11%2F04%2FICPCxuzhou2019%2F</url>
    <content type="text"><![CDATA[第一场区域赛结束了，过程属实坎坷，结果还算不错，复盘一下这两天。第一天热身赛。咕晚上9点多到的徐州，我真没想到到酒店的那一刻，全队只有我还有身份证睡觉的时候房间里还有蚊子，迫使我黑夜里徒手抓蚊子抓到了12点半多第二天7点不到起床（好久没这么早起过床了有一说一，这酒店早饭不错（虽然第三天起床已经是11点多的事情了到矿大还坐了半个小时等开场，第一次打区域赛说不紧张是不可能的（于是最后背了血锅开场以后我从后往前看题，分别看到了银牌题$M$（求所有子树重心），金牌题$G$（分解完全图），金牌题$H$（树套树套树），看了一连n道题，基本全没思路，完全找不到签到题的影子，只能继续往前看。hyq看了$A$感觉能做就先想起来了，syr看完比赛环境也加入看题阵营。$10min$后开始有队伍把$C$过了，我们就改变思路先来看$C$。发现$C$是求区间内素数个数是否占区间的$\frac{1}{3}$以上，想了想按素数的分布来说只要区间长度够大答案一定是否定的，只要考虑小区间长度逐个判断就够了。$31minC\quad1A$在syr码C的同时我开始继续往后看题，发现$F$也可做且有队伍$AC$了$F：$求$a^3+b^3+c^3=x $在$|a|,|b|,|c|≤5000,0≤x≤200$时的解，无解输出impossible想到这道题可以暴力打出表直接输出，不过显然$125\times 10^9\times200$的运算量恐怕到比赛结束我们还没有打完表再改变思路把式子变为$c^3=x-a^3-b^3$对 $c$ 开始二分找答案，找到所有impossible的情况记录下来直接输出，同时由于 $a,b,c$ 中至少有一个数为正数，因此可以再次缩短二分的时间。打了$5min$的表提交。$80minF\quad1A$做完前两道题的时间其实并不慢，这个时候我开始来看$A$了，也开始霸占机位直到比赛快结束了。$A：$求区间$[l,r]$内最多多少个数的异或$≤s$发现这道题给的数据范围特别大$1\le T\le 5\times10^5$，$1\le l\le r\le 10^{18}$，$1\le s\le2\times10^{18}$不可能是暴力的题，一定是异或的规律题。打了从$1$开始的异或表发现，每$2$个数字会出现$1$个$1$，再每$2$个数字会出现$1$个$0$，感觉每2个数字之间应该有些联系。于是开始找偶数与奇数的关系，发现偶数与奇数异或的结果是$1$，自然偶数个偶数和奇数对的异或结果是$0$，奇数和偶数似乎没什么联系。开始猜结论，找第一个偶数和最后一个奇数，计算有多少对偶数和奇数的结果，最后再异或上头和尾取可取范围内更长的就好了（于是本场最大的锅开始了结论确实猜对了（其实也不算对，必然有更简单的做法，比如蔡队说的异或前缀和，然后分四类讨论即可我也开始本场第一次摸键盘，也就是状态百出的开始，代码敲的感觉和去年这个时候的自己有得一拼。写完之后直接冲了一发，$1WA$到手，发现这样的代码需要一堆的特判，特判全部加上去之后，果断再冲一发，$2WA$到手。这个时候我心态的问题开始了，完全没有debug之前自己代码的欲望（其实离$AC$已经不远了，直接暴力对拍可能就找到问题了上了个厕所回来做出了本场最错误的决定，把之前的代码直接重构了一遍，结果越重构越错，对着重构的代码debug了一个小时无果，继续退回到前一个版本的代码上去。然而这个时候已经封榜了，我也霸占了$2h$机器了（吐槽一下这个榜，封榜就不能好好封吗，学一学domjudge不行吗，封榜居然是真的封全榜，让人提心吊胆的回到前一个版本的代码，暴力对拍之后发现问题出现了，忘记考虑异或了$l$后结果可能$&gt;s$，但再异或$r$后结果会$&lt;s$的可能性（其实在想思路的时候这种情况是考虑到了的，但是写的时候却出现了意外最后都不敢交代码了，所幸是过了这道题$260minA\quad5A$最后还剩下$40min$不过那个时候我的脑子已经僵住了，虽然想再想一道题出来，但是已经思考不动了$3$题结束第一场区域赛结束之后一直在看榜，看到在封榜前我们是2题首（是真的首，而且那个排名正好卡在铜牌线上最后是$454min \quad3$题结束，算了算前面的人数感觉拿牌子的可能性还是很大的。过了一会阿付去后台偷了波数据得知，$150$名，卡进铜了。本来悬着的心终于放下了。第一次打区域赛，得了个铜，有一说一还是很兴奋的，剩下的题对于我们来说也确实算是不可做题，算法内容都是之前在训练的时候没有接触过的内容，知道了自己还有很大的不足，需要在以后的训练中继续努力，加强，提升自己，希望下次能有更好的成绩吧。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>现场赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Max Sum——HDU1003(基础dp)]]></title>
    <url>%2F2019%2F10%2F16%2Fhdu1003%2F</url>
    <content type="text"><![CDATA[还有两个礼拜，先从基础dp做起，发现自己dp是真的菜，最基础的想了很久才想明白题目vj链接DescriptionGiven a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.InputThe first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).OutputFor each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.Sample Input12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5Sample Output12345Case 1:14 1 4Case 2:7 1 6题解求最大的子序列和设dp[n]是以a[n]结尾的最大子序列和可以发现例如：以$a[0]$结尾的子序列有$a[0]$以$a[1]$结尾的子序列有$a[0]a[1],a[1]$以$a[2]$的子序列有$a[0]a[1]a[2],a[1]a[2],a[2]$那么以a[n]结尾的子序列，若要满足子序列的和最大要么是$dp[i-1]+a[n]$要么是$a[n]$这是由于例如在求以$a[2]$结尾的子序列和最大时，$max = a[2]+max(a[0]a[1],a[1],0)$而$max(a[0]a[1],a[1])$恰好时$dp[i-1]$的结果，因此上式可以划为$max = a[2] + max(dp[i-1],0)$即$max = max(dp[i-1]+a[2],a[2])$因此可以递推求出$dp[n]$得到$dp[n]$的同时，可以与ans比较，更大则更新ans，且右端下标一定是i对于左端下标的处理，增加一个变量temp，记录可能的左端下标当$dp[i]&lt;0$时，temp = i+1因为当前$dp[i]&lt;0$而负数的和必然更小，因此可能的区间一定在右边在更新ans时，将左端下标更新为temp即可代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int inf = 0x3f3f3f3f;int a[maxn],low[maxn],dp[maxn];int t,ans,n,Case;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); dp[i] = -inf; &#125; int s=1,e=1,sum=a[1],temp=1; dp[1] = a[1]; for(int i=1;i&lt;=n;i++) &#123; dp[i] = max(dp[i-1]+a[i],a[i]); if(dp[i]&gt;=sum) &#123; sum = dp[i]; s = temp; e = i; &#125; if(dp[i]&lt;0) temp = i+1; &#125; printf("Case %d:\n",++Case); printf("%d %d %d\n",sum,s,e); if(t) printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 590 (Div. 3)]]></title>
    <url>%2F2019%2F10%2F09%2Fcodeforces590div3%2F</url>
    <content type="text"><![CDATA[前言状态属实差的一个月，也不知道算调整好了没有，不过生活总得继续，要开始努力训练了！要开心！找了场最近的Div3补一下题（试图补完所有的题，果然失败了A.Equalize Prices Again题面：Equalize Prices Again题意：对于q个询问，每次询问给n个数，求最小的$ans*n≥\sum_{i=0}^na[i]$题解：设$sum=\sum_{i=0}^n a[i]$ 则 $ans=\lceil\frac{sum}{n}\rceil$代码：123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int q,n,sum,m;int main()&#123; scanf("%d",&amp;q); while(q--) &#123; scanf("%d",&amp;n); sum = 0; for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;m); sum += m; &#125; cout&lt;&lt;(sum%n==0?sum/n:sum/n+1)&lt;&lt;endl; &#125;&#125;B.Social Network题面：Social Network (easy version)Social Network (hard version)题意：给定n,k，n为一天接收多少信息，k为手机最多能显示几条消息，同一个人的消息不会出现2次，只有当手机已经显示k条消息（即k个人的消息）且新消息来自第k+1个人，则第1个人的消息将被删除且显示第k+1个人的消息，求最后显示了几个人的消息以及顺序题解：虽然完全没有明白这个easy version要怎么暴力，显然并不妨碍一份代码交两道题用queue不断push进新的人，queue.size()&gt;=k时进去的新的人前先pop即可，不过这些人$1\leq id_{i}\leq 10^9$所以还需要再加个map存一下id代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+5;int n,k,id;bool vis[maxn];map&lt;int,int&gt; name;int num;int main()&#123; scanf("%d%d",&amp;n,&amp;k); queue&lt;int&gt; q; for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;id); map&lt;int,int&gt;::iterator it; it = name.find(id); if(it == name.end()) name[id] = ++num; if(!vis[name[id]]) vis[name[id]] = 1; else continue; if(q.size() == k) &#123; int temp = q.front(); q.pop(); vis[name[temp]] = 0; &#125; q.push(id); &#125; int length = q.size(); printf("%d\n",length); vector&lt;int&gt; que; while(!q.empty()) &#123; que.push_back(q.front()); q.pop(); &#125; for(int i=que.size()-1;i&gt;0;i--) printf("%d ",que[i]); printf("%d\n",que[0]);&#125;C.Pipes题面：Pipes题意：对于6种水管，4种弯曲，2种不弯曲，可以任意旋转对于给定的水管图，2*n的矩形，求是否可以从左上角抵达右下角题解：可以发现，因为6种水管可以任意旋转，所以4种弯曲的是同一种，2种不弯曲的是同一种同时由于矩形只是2*n的，所以对于不弯曲的水管来说，只能向右前进对于弯曲的水管来说，若同一列有一个是弯曲的，有一个是不弯曲的，那么一定不能继续前进，此时是NO对于同一列两个都是弯曲的，则将会在向右前进的同时改变行照着这个思路模拟即可虽然莫名其妙的，模拟错了很多次（太菜了代码：代码贴两份吧，毕竟这道题自己写的像弱智，贴一下标程自己写的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int a[2][maxn];int q,n;int main()&#123; scanf("%d",&amp;q); while(q--) &#123; memset(a,0,sizeof(a)); scanf("%d",&amp;n); for(int i=0;i&lt;2;i++) &#123; string s; cin&gt;&gt;s; for(int j=0;j&lt;s.length();j++) &#123; int temp = s[j] - '0'; if(temp==1 || temp==2) a[i][j] = 1; else a[i][j] = 2; &#125; &#125; int pos1 = 0, pos2 = 0; int prev1 = 0, prev2 = 0; bool can_vis = 1; while(1) &#123; if(a[pos1][pos2]==1) &#123; pos2++; if(pos1 == 1 &amp;&amp; pos2 == n) break; &#125; else if(a[0][pos2] == a[1][pos2]) &#123; if(pos1 == 1) &#123; pos1 = 0; pos2++; &#125; else &#123; pos2++; if(pos2 == n) break; pos1=1; &#125; &#125; else can_vis = 0; if(pos2&gt;=n) can_vis = 0; if(!can_vis) break; &#125; if(can_vis) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125;&#125;/*53565262652*/标程：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;#ifdef _DEBUG freopen("input.txt", "r", stdin);// freopen("output.txt", "w", stdout);#endif int q; cin &gt;&gt; q; for (int i = 0; i &lt; q; ++i) &#123; int n; string s[2]; cin &gt;&gt; n &gt;&gt; s[0] &gt;&gt; s[1]; int row = 0; int pos = 0; for (pos = 0; pos &lt; n; ++pos) &#123; if (s[row][pos] &gt;= '3') &#123; if (s[row ^ 1][pos] &lt; '3') &#123; break; &#125; else &#123; row ^= 1; &#125; &#125; &#125; if (pos == n &amp;&amp; row == 1) &#123; cout &lt;&lt; "YES" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "NO" &lt;&lt; endl; &#125; &#125; return 0;&#125;D.Distinct Characters Queries题面：Distinct Characters Queries题意：给定一个字符串，定义两种操作：1 x y 将 x 处的字符改为y2 x y 查询$[x,y]$内有多少个不同的字符数题解：感觉是个线段树的题，syr一眼秒杀状压线段树（tql由于只有26个字母，状压进线段树，把PushUp改为|，Query也改成|那么Query得到的答案就是字符的数量，处理一下这个数二进制有多少个1就完事了代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1using namespace std;typedef long long ll;const int maxn = 1e5 + 5; //元素个数int sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记int a[maxn],n,q; //a为原[1,n]数组string str;//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] | sum[rson];&#125;//Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; sum[pos] = 1 &lt;&lt; (str[l-1]-'a'); //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;void UpdatePoint(int L, int C, int l, int r, int pos) //对a[L] += C&#123; if(l == r) &#123; sum[pos] = C; return ; &#125; int m = (l + r) &gt;&gt; 1; if(L &lt;= m) //L在中点左侧，在左侧更新 &#123; UpdatePoint(L,C,l,m,lson); &#125; else //L在中点右侧，在右侧更新 &#123; UpdatePoint(L,C,m+1,r,rson); &#125; PushUp(pos); //当前节点更新&#125;int Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //答案 int ans = 0; if(L &lt;= m) ans |= Query(L,R,l,m,lson); if(R &gt; m) ans |= Query(L,R,m+1,r,rson); return ans;&#125;int cnum(int ans)&#123; int cnt = 0; while(ans) &#123; if(ans&amp;1) cnt++; ans&gt;&gt;=1; &#125; return cnt;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;str; cin&gt;&gt;q; n = str.length(); Build(1,n,1); while(q--) &#123; int x; cin&gt;&gt;x; if(x == 1) &#123; int y;char z; cin&gt;&gt;y&gt;&gt;z; int temp = 1 &lt;&lt; (z-'a'); UpdatePoint(y,temp,1,n,1); &#125; else &#123; int y,z; cin&gt;&gt;y&gt;&gt;z; int res = Query(y,z,1,n,1); int ans = cnum(res); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;&#125;E.Special Permutations题面：E - Special Permutations题意：给定函数$pos(p,i)$表示 $i$ 这个数字在 $p$ 这个排列中的位置同时规定$p_{i}(n)$表示这样的序列$[i,1,2,…,i-1,i+1,…,n]$即将 $i$ 放到序列首位，其他所有元素向后移一位同时在定义函数$f(p)=\sum_{i=1}^{m-1} \vert pos(p,x_{i})-pos(p,x_{i+1})\vert$给定n，m以及长度为m的序列$x_{m}$需要输出$f(p_{1}(n)),…,f(p_{n}(n))$题解：说实话，这题看了题解才想明白，syr又给秒杀了，我傻了题意对我来说就不好看懂，对于每一个$p_{i}$序列，需要计算$x_{m}$序列里每两项，在序列中的位置差由于数据范围是$2\le n,m\le 2·10^5$所以裸的暴力是不可行的精妙的题解告诉我们，只需要算$x_{m}$序列中每两项对于$f(p_{1}(n)),…,f(p_{n}(n))$中每一项的贡献即可至于这个贡献，分析$x_{m}$序列可知：取 $x_{m}$ 序列中两项，记为 $l,r$ 如果 $l&lt;r$ 则交换一下 $l,r$对于$for\quad i=1\dots n$若 $i$ 不在区间 $[l,r]$内，则可知 $l,r$ 两个数只对 $[1,l-1]$和 $[r+1,n]$有贡献，贡献为 $l-r$若 $i$ 为区间 $[l,r]$ 的左端点，则可知此时 $l$ 处于序列的首位，那么对 $f(p_{i}(n))$贡献为 $r-1$若 $i$ 为区间 $[l,r]$ 的右端点，则可知此时 $r$ 处于序列的首位，那么对 $f(p_{i}(n))$贡献为 $l$若 $i$ 在区间 $[l,r]$ 内，则 $l,r$ 对 $[l+1,r-1]$ 的贡献为 $l-r-1$ 因为相当于 $l,r$ 间少了一个数以上4种情况即包含了所有的情况，可以发现，这就是区间加减的问题，于是差分就派上用场了在题解里顺便讲一下差分，差分可以对多次的区间加减操作在 $O(n)$ 的复杂度完成差分操作需要用到一个差分数组 $d[n]$ 初始时所有元素为0对于每个区间加减的操作，对区间 $[l,r] + val$ ，只需要对 $d[l] += val, d[r+1]-=val$即可可以发现，若是对差分数组做前缀和操作，区间 $[l,r]$ 就变成了需要得到的结果只需要处理完所有的操作之后，做个前缀和就完事了，最后把差分数组加到原数组上就解决了因此这道题可以先 $O(m)$ 处理差分数组，最后 $O(n)$ 得到答案就好了代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;typedef long long ll;int n,m;int a[maxn];ll sum[maxn];void up(int l,int r,int val) //对区间[l,r] +/- val&#123; sum[l] += val; sum[r+1] -= val; return ;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;m;i++) &#123; int l = a[i-1],r = a[i]; if(l &gt; r) swap(l,r); if(l != r) &#123; up(1,l-1,r-l); up(l,l,r-1); up(l+1,r-1,r-l-1); up(r,r,l); up(r+1,n,r-l); &#125; &#125; for(int i=1;i&lt;n;i++) &#123; sum[i] = sum[i] + sum[i-1]; printf("%lld ",sum[i]); &#125; printf("%lld\n",sum[n]+sum[n-1]);&#125;F.Yet Another Substring Reverse题面：Yet Another Substring Reverse题解：无看题解是道状压dp，直接弃了]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训第二周——线段树 树状数组]]></title>
    <url>%2F2019%2F08%2F07%2Fsummer-2ndweek1%2F</url>
    <content type="text"><![CDATA[已经到集训第二周周末了，趁着有空补一下集训的博客，先把这周的补了，看看什么时候有空再补第一周的第一天线段树 树状数组（根本不会1st day——线段树 树状数组好像在实验室？（大概码完7道回去拿显示器了线段树主要是区间修改的lazy标记比较重要有骚操作的题目里再复习复习其他的直接贴题目了A.HDU1166链接：HDU1166线段树裸题？（大概是吧 忘记了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;#define lson pos&lt;&lt;1#define rson pos&lt;&lt;1|1const int maxn=1e5 + 7;int a[maxn &lt;&lt; 2];int n,r,ca_se=0,i,j,sum;char str[10];void pushup(int pos)&#123; a[pos]=a[lson]+a[rson];&#125;void build(int L,int R,int pos)&#123; if(L==R) &#123; scanf("%d",&amp;a[pos]); return; &#125; int mid = (L+R)&gt;&gt;1; build(L,mid,lson); build(mid+1,R,rson); pushup(pos);&#125;void update(int k,int val,int L,int R,int pos)&#123; if(L==R) &#123; a[pos]+=val; return; &#125; int mid=(L+R)&gt;&gt;1; if(k&lt;=mid) update(k,val,L,mid,lson); else &#123; update(k,val,mid+1,R,rson); &#125; pushup(pos); &#125;int query(int l,int r,int L,int R,int pos)&#123; if(l&lt;=L &amp;&amp; r&gt;=R) return a[pos]; int mid=(L+R)&gt;&gt;1; int res=0; if(l&lt;=mid) res+=query(l,r,L,mid,lson); if(r &gt; mid) res+=query(l,r,mid+1,R,rson); return res;&#125;int main()&#123; scanf("%d",&amp;n); while(n--) //Case i: &#123; printf("Case %d:\n",++ca_se); scanf("%d",&amp;r); build(1,r,1); while(scanf("%s",str),strcmp(str,"End")) &#123; if(!strcmp(str,"Add")) &#123; scanf("%d%d",&amp;i,&amp;j); update(i,j,1,r,1); &#125; if(!strcmp(str,"Sub")) &#123; scanf("%d%d",&amp;i,&amp;j); update(i,-j,1,r,1); &#125; if(!strcmp(str,"Query")) &#123; scanf("%d%d",&amp;i,&amp;j); sum=query(i,j,1,r,1); cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;B.HDU1754链接：HDU175412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define lson pos&lt;&lt;1#define rson pos&lt;&lt;1|1using namespace std;int n,m,i,j,ans;const int maxn = 1e7 + 7;int a[maxn &lt;&lt; 2];void pushup(int pos)&#123; a[pos]=max(a[lson],a[rson]);&#125;void build(int L,int R,int pos)&#123; if(L==R) &#123; scanf("%d",&amp;a[pos]); return; &#125; int mid=(L+R)&gt;&gt;1; build(L,mid,lson); build(mid+1,R,rson); pushup(pos);&#125;void update(int k,int val,int L,int R,int pos)&#123; if(L==R) &#123; a[pos]=val; return; &#125; int mid=(L+R)&gt;&gt;1; if(k&lt;=mid) update(k,val,L,mid,lson); else update(k,val,mid+1,R,rson); pushup(pos);&#125;int query(int l,int r,int L,int R,int pos)&#123; if(l&lt;=L &amp;&amp; r&gt;=R) return a[pos]; int mid=(L+R)&gt;&gt;1; int res=0; if(l&lt;=mid) res=max(res,query(l,r,L,mid,lson)); if(r&gt;mid) res=max(res,query(l,r,mid+1,R,rson)); return res;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,n,1); char way; for(int q=0;q&lt;m;q++) &#123; cin&gt;&gt;way&gt;&gt;i&gt;&gt;j; if(way=='Q') &#123; ans=query(i,j,1,n,1); cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; update(i,j,1,n,1); &#125; &#125; &#125; return 0;&#125;C.HDU1394链接：HDU1394求循环移位后逆序对的最小数先利用线段树求逆序对，再处理即满足 i&gt;j &amp;&amp; a[i]&lt;a[j]的数量总感觉是归并排序题，不过线段树也可以求由于求逆序对的过程可以视为，将数组保存下来之后，对每个元素查询所有比他大的数朴素方法复杂度为$O(n^2)$但是查找的操作可以利用线段树解决因此复杂度降低为$O(nlogn)$线段树做法线段树是这样处理逆序对的1.将线段树的叶子节点作为每个数的对应位置2.对于第i个数，我们需要知道插入i之前有多少个数比i大3.即查询a[i]到n的数的个数即可逆序数求得之后，把第一个数移到最后的逆序数是可以直接得到的这是由于对于a[i]这个数而言，若将a[i]移动到数列的最后位1.原先与a[i]构成逆序对的数（即原来比a[i]小的数）现在不再构成逆序对2.原先与a[i]不构成逆序对的数（即原来比a[i]大的数）现在会构成逆序对对于这样一个序列$0,1,2…n-1$比a[i]小的数有a[i]个比a[i]大的数有n-a[i]-1个因此减少$a[i]$个，增加$n-a[i]-1$个比如原来的逆序数是ans,把a[0]移到最后后，减少逆序数a[0]，同时增加逆序数n-a[0]-1个就是123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106```c++#include &lt;bits/stdc++.h&gt;#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1using namespace std;const int maxn = 5005; //元素个数int sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记int a[maxn],n; //a为原[1,n]数组//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] + sum[rson];&#125;//PushDown函数 下推延迟标记void PushDown(int pos, int ln, int rn)//ln,rn为左右子树的数量&#123; if(add[pos]) &#123; //标记下推 add[lson] += add[pos]; add[rson] += add[pos]; //修改子节点的sum值 sum[lson] += add[pos]*ln; sum[rson] += add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125;&#125;//Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; sum[pos] = 0; //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;void UpdatePoint(int L, int l, int r, int pos) //对a[L] += C&#123; if(l == r) &#123; sum[pos]++; return ; &#125; int m = (l + r) &gt;&gt; 1; PushDown(pos, m - l + 1, r - m); if(L &lt;= m) //L在中点左侧，在左侧更新 &#123; UpdatePoint(L,l,m,lson); &#125; else //L在中点右侧，在右侧更新 &#123; UpdatePoint(L,m+1,r,rson); &#125; PushUp(pos); //当前节点更新&#125;int Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //下推标记 PushDown(pos, m - l + 1, r - m); //答案 int ans = 0; if(L &lt;= m) ans += Query(L,R,l,m,lson); if(R &gt; m) ans += Query(L,R,m+1,r,rson); return ans;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; memset(sum,0,sizeof(sum)); memset(a,0,sizeof(a)); Build(0,n,1); int cnt = 0; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); UpdatePoint(a[i],0,n,1); cnt += (i-Query(0,a[i],0,n,1)); &#125; int min1 = cnt; for(int i=1;i&lt;=n;i++) &#123; cnt-=a[i]; cnt+=n-a[i]-1; min1 = min(min1,cnt); &#125; cout&lt;&lt;min1&lt;&lt;endl; &#125;&#125;归并排序做法待补，还不会归并排序（逃D.HDU1698链接：HDU1698印象里好像是道区间修改的板子题还因为输出格式wa了一发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1using namespace std;typedef long long ll;const int maxn = 100005; //元素个数int sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记int a[maxn],n,q; //a为原[1,n]数组int t,x,y,z,Case;//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] + sum[rson];&#125;//PushDown函数 下推延迟标记void PushDown(int pos, int ln, int rn)//ln,rn为左右子树的数量&#123; if(add[pos]) //区间改值 &#123; //标记下推 add[lson] = add[pos]; add[rson] = add[pos]; //修改子节点的sum值 sum[lson] = add[pos]*ln; sum[rson] = add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125; /*if(add[pos]) //区间加减 &#123; //标记下推 add[lson] += add[pos]; add[rson] += add[pos]; //修改子节点的sum值 sum[lson] += add[pos]*ln; sum[rson] += add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125;*/&#125;//Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; sum[pos] = a[l]; //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;void UpdateInterval(int L, int R,int C,int l, int r, int pos) //对a[L,R] += C，或a[L,R] = C&#123; if(L &lt;= l &amp;&amp; r &lt;= R) //[l,r]区间完全包含在[L,R]区间内 &#123; add[pos] = C; sum[pos] = C*(r-l+1); /*sum[pos] += C*(r-l+1); //区间加减 add[pos] += C;*/ return ; &#125; int m = (l + r) &gt;&gt; 1; PushDown(pos, m - l + 1, r - m); if(L &lt;= m) &#123; UpdateInterval(L,R,C,l,m,lson); &#125; if(R &gt; m) &#123; UpdateInterval(L,R,C,m+1,r,rson); &#125; PushUp(pos);&#125;int Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //下推标记 PushDown(pos, m - l + 1, r - m); //答案 int ans = 0; if(L &lt;= m) ans += Query(L,R,l,m,lson); if(R &gt; m) ans += Query(L,R,m+1,r,rson); return ans;&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; memset(sum,0,sizeof(sum)); memset(add,0,sizeof(add)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i]=1; Build(1,n,1); scanf("%d",&amp;q); while(q--) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); UpdateInterval(x,y,z,1,n,1); &#125; int temp = Query(1,n,1,n,1); printf("Case %d: The total value of the hook is %d.\n",++Case,temp); &#125;&#125;E.POJ3468链接：POJ3468贴了个vj地址上道是区间改值的板子题这道是区间加减的板子题（应该直接贴代码了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1using namespace std;typedef long long ll;const int maxn = 100005; //元素个数ll sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记ll a[maxn],n,q; //a为原[1,n]数组char Q;int x,y,z;//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] + sum[rson];&#125;//PushDown函数 下推延迟标记void PushDown(int pos, int ln, int rn)//ln,rn为左右子树的数量&#123; if(add[pos]) &#123; //标记下推 add[lson] += add[pos]; add[rson] += add[pos]; //修改子节点的sum值 sum[lson] += add[pos]*ln; sum[rson] += add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125;&#125;//Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; scanf("%lld",&amp;sum[pos]); //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;void UpdateInterval(int L, int R,int C,int l, int r, int pos) //对a[L,R] += C&#123; if(L &lt;= l &amp;&amp; r &lt;= R) //[l,r]区间完全包含在[L,R]区间内 &#123; sum[pos] += C*(r-l+1); add[pos] += C; return ; &#125; int m = (l + r) &gt;&gt; 1; PushDown(pos, m - l + 1, r - m); if(L &lt;= m) &#123; UpdateInterval(L,R,C,l,m,lson); &#125; if(R &gt; m) &#123; UpdateInterval(L,R,C,m+1,r,rson); &#125; PushUp(pos);&#125;ll Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //下推标记 PushDown(pos, m - l + 1, r - m); //答案 ll ans = 0; if(L &lt;= m) ans += Query(L,R,l,m,lson); if(R &gt; m) ans += Query(L,R,m+1,r,rson); return ans;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;q)!=EOF) &#123; memset(sum,0,sizeof(sum)); memset(add,0,sizeof(add)); Build(1,n,1); while(q--) &#123; cin&gt;&gt;Q; if(Q=='Q') &#123; scanf("%d%d",&amp;x,&amp;y); ll temp = Query(x,y,1,n,1); printf("%lld\n",temp); &#125; else &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); UpdateInterval(x,y,z,1,n,1); &#125; &#125; &#125;&#125;F.POJ2777链接：POJ2777很有意思的一道题（自我认为线段树+状压（做题的时候真的意识不到可以这么状压 是真的菜一共30种可能性，量不大，可以直接压成二进制用一个数的每个二进制位来表示那么在表示这一段有多少种颜色时可以直接 | 一下就得到了颜色的种类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//只有30种情况可以考虑位操作#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1using namespace std;typedef long long ll;const int maxn = 100005; //元素个数long long sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记int a[maxn],n,q; //a为原[1,n]数组int T,x,y,z,Case;//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] | sum[rson];&#125;//PushDown函数 下推延迟标记void PushDown(int pos, int ln, int rn)//ln,rn为左右子树的数量&#123; if(add[pos]) //区间改值 &#123; //标记下推 add[lson] = add[pos]; add[rson] = add[pos]; //修改子节点的sum值 sum[lson] = add[pos]; sum[rson] = add[pos]; //清楚当前节点标记 add[pos] = 0; &#125; /*if(add[pos]) //区间加减 &#123; //标记下推 add[lson] += add[pos]; add[rson] += add[pos]; //修改子节点的sum值 sum[lson] += add[pos]*ln; sum[rson] += add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125;*/&#125;//Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; sum[pos] =1; //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;void UpdateInterval(int L, int R,int C,int l, int r, int pos) //对a[L,R] += C，或a[L,R] = C&#123; if(L &lt;= l &amp;&amp; r &lt;= R) //[l,r]区间完全包含在[L,R]区间内 &#123; add[pos] = C; sum[pos] = C; /*sum[pos] += C*(r-l+1); //区间加减 add[pos] += C;*/ return ; &#125; int m = (l + r) &gt;&gt; 1; PushDown(pos, m - l + 1, r - m); if(L &lt;= m) &#123; UpdateInterval(L,R,C,l,m,lson); &#125; if(R &gt; m) &#123; UpdateInterval(L,R,C,m+1,r,rson); &#125; PushUp(pos);&#125;long long Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //下推标记 PushDown(pos, m - l + 1, r - m); //答案 long long ans = 0; if(L &lt;= m) ans |= Query(L,R,l,m,lson); if(R &gt; m) ans |= Query(L,R,m+1,r,rson); return ans;&#125;int cnum(long long ans)&#123; int cnt = 0; while(ans) &#123; if(ans&amp;1) cnt++; ans&gt;&gt;=1; &#125; return cnt;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;T,&amp;q); Build(1,n,1); while(q--) &#123; char alp; cin&gt;&gt;alp; if(alp == 'C') &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(x&gt;y) swap(x,y); UpdateInterval(x,y,1&lt;&lt;(z-1),1,n,1); &#125; else &#123; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y) swap(x,y); long long temp = Query(x,y,1,n,1); int res = cnum(temp); printf("%d\n",res); &#125; &#125;&#125;G.HDU1542 待补链接：HDU1542没做 待补H.HDU4027链接：HDU4027这道题也 挺有意思（？与一般的区间修改不同这道题是对区间内的值直接开方因此延迟标记将完全 莫得用处那么可以直接一点 暴力一点 然后就过了因为最大也就$2^{63}$大小，开方最多也就开7次就会变成1因此只需要开方到1就跳过 剩下的就是暴力的事情了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1using namespace std;typedef long long ll;const int maxn = 100005; //元素个数long long sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记long long a[maxn],n,q; //a为原[1,n]数组long long x,y,z,Case;//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] + sum[rson];&#125;//PushDown函数 下推延迟标记/*void PushDown(int pos, int ln, int rn)//ln,rn为左右子树的数量&#123; if(add[pos]) //区间改值 &#123; //标记下推 add[lson] = add[pos]; add[rson] = add[pos]; //修改子节点的sum值 sum[lson] = add[pos]; sum[rson] = add[pos]; //清楚当前节点标记 add[pos] = 0; &#125; if(add[pos]) //区间加减 &#123; //标记下推 add[lson] += add[pos]; add[rson] += add[pos]; //修改子节点的sum值 sum[lson] += add[pos]*ln; sum[rson] += add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125;&#125;*///Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; sum[pos] = a[l]; //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;void UpdateInterval(int L, int R,int l, int r, int pos) //对a[L,R] += C，或a[L,R] = C&#123; if(sum[pos] == r-l+1) return; if(l == r) //[l,r]区间完全包含在[L,R]区间内 &#123; sum[pos] = floor(sqrt(sum[pos])); /*sum[pos] += C*(r-l+1); //区间加减 add[pos] += C;*/ return ; &#125; int m = (l + r) &gt;&gt; 1; if(L &lt;= m) &#123; UpdateInterval(L,R,l,m,lson); &#125; if(R &gt; m) &#123; UpdateInterval(L,R,m+1,r,rson); &#125; PushUp(pos);&#125;long long Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //下推标记 //PushDown(pos, m - l + 1, r - m); //答案 long long ans = 0; if(L &lt;= m) ans += Query(L,R,l,m,lson); if(R &gt; m) ans += Query(L,R,m+1,r,rson); return ans;&#125;int main()&#123; while(scanf("%lld",&amp;n)!=EOF) &#123; printf("Case #%d:\n",++Case); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); Build(1,n,1); scanf("%lld",&amp;q); while(q--) &#123; scanf("%lld%lld%lld",&amp;z,&amp;x,&amp;y); if(z==0) &#123; if(x&gt;y) swap(x,y); UpdateInterval(x,y,1,n,1); &#125; else &#123; if(x&gt;y) swap(x,y); printf("%lld\n",Query(x,y,1,n,1)); &#125; &#125; printf("\n"); &#125;&#125;I.HYSBZ - 1018 待补链接：HYSBZ - 1018没做 待补]]></content>
      <categories>
        <category>题解</category>
        <category>暑假集训</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论最小生成树]]></title>
    <url>%2F2019%2F07%2F07%2Fspanning-tree%2F</url>
    <content type="text"><![CDATA[图论入门的另一基本问题就是求最小生成树，写一下理解，记录一下模板1.概述先定义几个关于图的概念：连通图：在无向图中，若任意两个顶点$v_{i}$和$v_{j}$有路径连通，则称该无向图为连通图强连通图：在有向图中，若任意两个顶点$v_{i}$和$v_{j}$有路径连通，则称该有向图为强连通图生成树：连通图的生成树为连通子图，即其含有全部的$n$个顶点，但只有足以构成树的$n-1$条边最小生成树：在所有的生成树中，边权和最小的生成树称之为最小生成树求最小生成树的问题一般使用 Prim算法和 Kruskal算法当然这两种算法在适合范围上有所区别：Prim算法适合稠密图，即边多的情况，其复杂度为O($V^2$)，V为顶点个数，与边无关Kruskal算法适合稀疏图，即边少的情况，其复杂度为O($ElogE$)，E为边数这两种算法在本质上来说都是贪心的结果2.Prim算法Prim算法以点为核心，不断地将点加入已选集合，最后构成最小生成树2.1算法思路对于一个加权连通图，其顶点集合为$V$，边集合为$E$需要设置两个数组 lowcost[maxn]和vis[maxn]用于表示点到数的最短距离和是否加入点集任意选择一个初始点，标记状态vis[s] = true开始寻找所有和它相连的点中距离最短的点，将其加入点集中更新其他未被访问的点到数的最短距离，再选择其中距离树最短的点加入点集中重复 2 直到所有点都被加入点集中去2.2实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;const int INF = 0x3f3f3f3f;bool vis[maxn];int lowcost[maxn];int N,ans; //顶点数量,最小生成树权值int graph[maxn][maxn]=&#123; &#123;0,7,4,INF,INF,INF&#125;, //INF代表两点之间不可达 &#123;7,0,6,2,INF,4&#125;, &#123;4,6,0,INF,9,8&#125;, &#123;INF,2,INF,0,INF,7&#125;, &#123;INF,INF,9,INF,0,1&#125;, &#123;INF,4,8,7,1,0&#125;&#125;;int Prim(int node)&#123; N = 6; memset(vis,0,sizeof(vis)); //初始化vis数组 vis[node] = true; for(int i=0;i&lt;N;i++) //更新lowcost数组 lowcost[i] = graph[node][i]; int cnt = 1; //将起点加入点集合 while(cnt != N) //当点集合数量不等于顶点数量时循环 &#123; int min1 = INF,pos; //设置最小值和其下标 for(int i=1;i&lt;N;i++) &#123; //若该点没有加入点集合，且lowcost小于最小值 if(!vis[i] &amp;&amp; min1 &gt; lowcost[i]) &#123; min1 = lowcost[i];//更新最小值 pos = i; //更新下标 &#125; &#125; vis[pos] = true; //将该点加入点集合 ans += min1; //答案加上最小权值 cnt++; //点集合数量+1 for(int i=0;i&lt;N;i++) //更新lowcost数组 &#123; lowcost[i] = min(lowcost[i],graph[pos][i]); &#125; &#125; return ans;&#125;int main()&#123; cout&lt;&lt;Prim(0)&lt;&lt;endl; return 0;&#125;3.KruskalKruskal与Prim正好相反，以边为重点，加边入集合，直到所有点都被连通3.1算法思路先将边的集合从小到大进行排序按边权值从小到大取边，若边的两端点$u_{i}$和$v_{i}$不在同一集合中，则将该边加入最小生成树中重复2，直到所有顶点都被选取根据上述思路，我们可以利用并查集很方便地实现Kruskal算法3.2实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int INF = 0x3f3f3f3f;//由于Kruskal需要排序，用结构体存边struct node&#123; int start; int end; int weight;&#125;edge[maxn];int ans,n,m; //答案，点数，边数int par[maxn]; //并查集父节点void init() //并查集初始化&#123; for(int i=0;i&lt;n;i++) par[i] = i;&#125;int find(int x) //并查集查找父节点（带路径压缩）&#123; if(par[x] == x) return x; else return par[x] = find(par[x]); //路径压缩&#125;bool cmp(node a,node b)&#123; return a.weight&lt;b.weight;&#125;int kruskal(int n)&#123; sort(edge,edge+m,cmp); //排序 int cnt = 0; //统计节点数量 ans = 0; //答案 for(int i=0;i&lt;m;i++) &#123; int start = edge[i].start; int end = edge[i].end; int pars = find(start); int pare = find(end); if(pars != pare) //起点和终点不在同一集合 &#123; par[pars] = par[pare];//两点集合合并 ans += edge[i].weight;//答案+上边权值 cnt++; //点数+1 &#125; if(cnt == n-1) //边数等于N-1则break break; &#125; if(cnt != n-1) //边数不等于n-1则说明不连通 return -1; else return ans;&#125;int main()&#123; while(cin&gt;&gt;m&gt;&gt;n &amp;&amp; m) &#123; init(); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;edge[i].start&gt;&gt;edge[i].end&gt;&gt;edge[i].weight; &#125; ans = kruskal(n); if(ans==-1) cout&lt;&lt;"?"&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论最短路问题]]></title>
    <url>%2F2019%2F07%2F06%2Fshortest-path%2F</url>
    <content type="text"><![CDATA[图论中，最短路问题是十分常见的一类问题，在此之前对最短路算法了解十分浅薄，借这篇文章的机会重新学习一下1.概述图论中的最短路问题一般用以下三种算法解决：单源最短路无负边：Dijkstra算法朴素算法的时间复杂度O($V^2$)，在利用堆优化后复杂度O($E logV$)单源最短路有负边：SPFA算法 即队列优化后的Bellman-Ford算法时间复杂度O($kE$)，最坏情况下时间复杂度O($VE$)多源最短路：Floyd算法时间复杂度O($V^3$) 暴力三循环2.存图有了最短路算法，我们首先需要解决存图的问题，可以使用邻接矩阵或邻接表实现2.1邻接矩阵邻接矩阵是我个人认为最方便直观的存图手段定义int mp[maxn][maxn]利用二维数组存储起点、终点、权值对于无向图存图时要注意mp[a][b]=mp[b][a]对于有向图无法到达的点设置为mp[a][b] = INF2.2邻接表邻接表的实现说实话我一直不会，趁着这个机会赶紧学习一下利用vector实现邻接表1234567const int maxn = 1e5 + 5;//点的数量struct edge&#123; int to; //该点指向的点 int val; //边上的权值&#125;;vector&lt;edge&gt; mp[maxn];mp[i]就表示从i点出发指向的其他点3.Dijkstra算法先放一篇对原理解释不错的博客：Dijkstra不过代码实现不适合比赛，且是朴素算法3.1算法思路Dijkstra算法就是按贪心来获得最短路，需要定义int d[maxn]来存储从起点到其他点的最短距离假设出发点为s，则设置d[s] = 0对于 s 能直接到达的任意点 m，若边权为w，则再令d[m] = w把所有其他不能直接从s到达的点距离设置为INF开始在d数组中寻找最小值，由于是单源无负边的最短路，因此此时查找到的最小值一定是从 s 点出发到达 m 点最短的距离，不存在第二个点周转之后有更短的距离，将该点 m 加入已经选中的点集中接着进行算法中最重要的松弛操作，将 m 点加入点集后，开始从 m 点出发，查找是否到达其他点的路径长度小于直接从源点出发的长度，借此来更新d数组反复以上操作，直到所有的点都被加入点集3.2朴素算法算法的思路很简单，然而若我们利用朴素算法实现Dijkstra算法，得到的复杂度将是O($V^2$)这样的复杂度是无法接受的，还不如选择SPFA算法，更为快捷因此朴素算法仅仅提一笔，没有实现3.3堆优化Dijkstra算法在利用优先队列进行堆优化后，时间复杂度可以由O($V^2$)降低至O($ElogV$)因为在朴素算法中，大量的时间都被用在查找下一个可使用的顶点上了，因此我们需要对该算法使用合适的数据结构进行优化（数据结构的重要性）对朴素算法，我们需要优化更新和取出最小值这两项操作，因此我们可以使用堆优化同时用邻接表存图，进一步降低复杂度以下以priority_queue实现，白书P102的实现while(优先队列非空)—&gt;队头出队，松弛它的边—&gt;松弛了的&lt;新距离,点&gt;入队12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int maxn = 1e5 + 5;const int INF = 0x3f3f3f3f;//first是最短距离 second是顶点的编号//利用pair与利用结构体相同typedef pair&lt;int,int&gt; P;struct edge&#123; int to; int val; edge(int a=0,int b=0) &#123; to = a; val = b; &#125;&#125;;vector&lt;edge&gt; mp[maxn]; //邻接表存图int d[maxn]; //存距离void dijkstra(int s) //起点&#123; //通过greater&lt;P&gt; 按照first从小到大取值 priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; memset(d,INF,sizeof(d));//所有距离设置为INF d[s] = 0; //起点的距离为0 que.push(P(0,s)); while(!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; //若到v点的距离，小于pair中存的最短距离 if(d[v] &lt; p.first) continue; //遍历邻接表中v点能到的所有点 for(int i=0;i&lt;mp[v].size();i++) &#123; edge e = mp[v][i]; //若直接到i点的距离大于先到v点再从v点到i点的距离 //则更新 if(d[e.to] &gt; d[v] + e.val) &#123; d[e.to] = d[v] + e.val; que.push(P(d[e.to],e.to)); &#125; &#125; &#125;&#125;再以下是队友的代码，复制一下123456789101112131415161718192021222324252627282930313233343536373839struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; //优先队列，从较小的开始出 Q.push(nod(N,0));//初始态,N为出发点 //类似BFS过程 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; //若能更新，则更新并把更新的点push进队列 if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125;4.SPFA算法SPFA算法的优点是显而易见的，可以处理有负边的情况，可以判负环，实现简单但同时SPFA的复杂度为O($VE$)，在效率是不如优化后的Dijkstra的4.1算法思路SPFA算法思路与Dijkstra有些类似定义int d[maxn]数组用于存储最短路径，用邻接表存图先将起点进队，每次取出队首，对队首节点进行松弛操作，若最短路径变化了且队首节点指向的点不在队列中则把该点进队不断取出节点松弛，直到队列为空为止while(队非空)—&gt;队头出队，松弛它的边—&gt;松弛了且不在队内的点入队4.1.1利用SPFA判负环当某点进队超过n次时存在负环（n为顶点数量）4.2实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 1e5 + 5;const int INF = 0x3f3f3f3f;struct edge&#123; int to; int val; edge(int a = 0, int b = 0) &#123; to = a; val = b; &#125;&#125;;vector&lt;edge&gt; mp[maxn]; //邻接表存图int d[maxn]; //最短距离bool vis[maxn]; //记录节点是否在队列里int EnqueNum[maxn]; //记录进队次数int PointNum; //节点数bool spfa(int s) //s为起点&#123; memset(d,INF,sizeof(d)); d[s] = 0; queue&lt;int&gt; que; //记录路径改变的点 que.push(s); vis[s] = true; EnqueNum[s]++; while(!que.empty()) &#123; int temp = que.front(); que.pop(); vis[temp] = false; for(int i = 0; i &lt; mp[temp].size(); i++) &#123; edge e = mp[temp][i]; //如果可以松弛 if(d[e.to] &gt; d[temp] + e.val) &#123; d[e.to] = d[temp] + e.val; //且该点不在队列里 if(!vis[e.to]) &#123; vis[e.to] = true; que.push(e.to); EnqueNum[e.to]++; if(EnqueNum[e.to] &gt;= PointNum) //判负环 return false; &#125; &#125; &#125; &#125; return true;&#125;5.Floyd算法Floyd算法用于实现多源最短路问题，然而他实在是太暴力了，复杂度O($n^3$)正常情况下不考虑5.1算法思路对于dis[i][j]表示顶点 i 到顶点 j 的最短距离，若存在顶点 k 借以中转有dis[i][k] + dis[k][j]更小，则可以更新dis[i][j]的距离5.2实现Floyd的代码实现 三循环一行代码 暴力的极致1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 570 (Div.3)]]></title>
    <url>%2F2019%2F07%2F06%2Fcf-570%2F</url>
    <content type="text"><![CDATA[晚上没事干又不想学新东西闲得无聊打一下cf，部分题有空再补链接：Codeforces Round #570 (Div. 3)A. Nearest Interesting Number题目链接：A. Nearest Interesting Number题目Polycarp knows that if the sum of the digits of a number is divisible by 33, then the number itself is divisible by 33. He assumes that the numbers, the sum of the digits of which is divisible by 44, are also somewhat interesting. Thus, he considers a positive integer nn interesting if its sum of digits is divisible by 44.Help Polycarp find the nearest larger or equal interesting number for the given number aa. That is, find the interesting number nn such that n≥an≥a and nn is minimal.InputThe only line in the input contains an integer aa (1≤a≤10001≤a≤1000).OutputPrint the nearest greater or equal interesting number for the given number aa. In other words, print the interesting number nn such that n≥an≥a and nn is minimal.Examplesinput1432output1435input199output1103题解各位数之和能被4整除即可代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;bool is_interstring(int x)&#123; int sum = 0; while(x) &#123; sum += x%10; x/=10; &#125; return sum%4 == 0;&#125;int main()&#123; int a; cin&gt;&gt;a; while(!is_interstring(a)) a++; cout&lt;&lt;a&lt;&lt;endl;&#125;B. Equalize Prices题目链接：B. Equalize Prices题目There are $n$ products in the shop. The price of the $i$-th product is $a_{i}$. The owner of the shop wants to equalize the prices of all products. However, he wants to change prices smoothly.In fact, the owner of the shop can change the price of some product $i$ in such a way that the difference between the old price of this product $a_{i}$ and the new price $b_{i}$ is at most $k$. In other words, the condition $|a_{i}−b_{i}|≤k $should be satisfied ($|x|$ is the absolute value of x).He can change the price for each product not more than once. Note that he can leave the old prices for some products. The new price $b_{i}$of each product $i$ should be positive (i.e. $b_{i}&gt;0$ should be satisfied for all $i$ from $1$ to $n$).Your task is to find out the maximum possible equal price $B$ of all productts with the restriction that for all products the condiion$|a_{i}−B|≤k $ should be satisfied (where $a_{i}$ is the old price of the product and $B$ is the same new price of all products) or report that it is impossible to find such price $B$.Note that the chosen price $B$ should be integer.You should answer $q$ independent queries.InputThe first line of the input contains one integer $q$ ($1≤q≤100$) — the number of queries. Each query is presented by two lines.The first line of the query contains two integers nn and $k$ ($1≤n≤100,1≤k≤108$) — the number of products and the value $k$. The second line of the query contains $n$ integers $a_{1},a_{2},…,a_{n}$($1≤a_{i}≤108$), where $a_{i}$ is the price of the $i$-th product.OutputPrint $q$ integers, where the $i$-th integer is the answer $B$ on the $i$-th query.If it is impossible to equalize prices of all given products with restriction that for all products the condition $|a_{i}−B|≤k$ should be satisfied (where $a_{i}$ is the old price of the product and $B$ is the new equal price of all products), print $-1$. Otherwise print the maximum possible equal price of all products.ExampleInput12345678945 11 1 2 3 14 26 4 8 52 21 63 55 2 5Output123426-17题解Ⅰ自己的思路：取中间值开始向右二分，直到找到最大的B代码Ⅰ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int min1 = 0x3f3f3f3f;int max1 = -min1;int a[105],b,c;int t,n,k;int bs(int l , int r)&#123; if(l == r) return l; else &#123; int m = (l + r) / 2; if((m+k&gt;=max1) &amp;&amp; (m-k&lt;=min1)) bs(m+1,r); else bs(l,m); &#125;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; min1 = 0x3f3f3f3f; max1 = -min1; bool can = 0; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; if(a[i] &lt; min1) min1 = a[i]; if(a[i] &gt; max1) max1 = a[i]; &#125; b = (max1 + min1) / 2; if((b+k&gt;=max1) &amp;&amp; (b-k&lt;=min1)) &#123; can = 1; &#125; if(!can) &#123; cout&lt;&lt;"-1"&lt;&lt;endl; continue; &#125; int l = b, r = min1 + k; b = bs(l,r); cout&lt;&lt;b&lt;&lt;endl; &#125;&#125;题解Ⅱ排序之后最小的数a[0] + k满足题意即可代码Ⅱ1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a[105];int main()&#123; int q; scanf("%d",&amp;q); while(q--)&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+n); int ans=a[1]+k; if(ans+k&lt;a[n])printf("-1\n"); else printf("%d\n",ans); &#125; return 0;&#125;C. Computer Game题目链接：C. Computer Game懒得写题目了直接写题解了题解Ⅰ暴力二分，满足(m*a)+(n-m)*b&lt;k即向右二分，否则向左二分代码Ⅰ1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;ll t,k,n,a,b,ans1,ans2;void ef(int l ,int r)&#123; if(l == r) return; ll m = (l + r) / 2; if((m*a)+(n-m)*b &lt; k &amp;&amp; m&lt;=n) &#123; ans1 = m; ef(m+1,r); &#125; else ef(l,m);&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;k&gt;&gt;n&gt;&gt;a&gt;&gt;b; ans1 = -1; ll l = 1, r = n; /*while(l &lt;= r) &#123; int m = (l + r) / 2; if((m*a)+(n-m)*b &lt; k) &#123; ans1 = m; l = m+1; &#125; else r = m-1; &#125;*/ ef(l,r+1); cout&lt;&lt;ans1&lt;&lt;endl; &#125;&#125;题解Ⅱ数学方法 数学太差了没办法还是不会发来悟一悟123ll resz=k-n*b;ll r=a-b;ll w=(resz-1)/r;代码Ⅱ12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll k, n, a, b;void test()&#123; scanf("%lld%lld%lld%lld", &amp;k, &amp;n, &amp;a, &amp;b); if (k&lt;=n*b) &#123; printf("-1\n"); return; &#125; ll resz=k-n*b; ll r=a-b; ll w=(resz-1)/r; w=min(w, n); printf("%lld\n", w);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) test(); return 0;&#125;DEFGH待补]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集实现]]></title>
    <url>%2F2019%2F07%2F05%2FUnion%2F</url>
    <content type="text"><![CDATA[并查集是用于管理元素分组的数据结构，利用这篇文章写一下自己的理解，记录一下模板继续放一篇优秀的博客，并查集1.概述并查集可以高效的实现以下操作：查询元素a、b属于同一组合并元素a、b所在的组2.实现用int par[maxn]存储节点的父节点若par[x] = x;则说明该节点即为根节点利用int rank[maxn]来存储树的高度，用以实现并查集的其中一个优化——按秩合并并查集另一优化是——路径压缩2.1初始化123456789//初始化n个元素void init(int n)&#123; for(int i = 0;i &lt; n;i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;初始化时，每一个元素都是根，且树高度为02.2查询根节点12345678//find函数 用于查询当前节点的根节点int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);//路径压缩&#125;在查询时，实现并查集的路径压缩，当没有找到根节点时，父节点 = 根节点2.3合并12345678910111213141516//合并x y所在集合void Unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return ; if(rank[x] &lt; rank[y]) par[x] = y; else &#123; par[y] = x; if(rank[x] == rank[y]) rank[x]++; &#125;&#125;按秩合并两个集合2.4判断是否属于同一集合1234bool same(int x, int y)&#123; return find(x) == find(y);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树入门]]></title>
    <url>%2F2019%2F07%2F04%2FSegment-Tree%2F</url>
    <content type="text"><![CDATA[线段树通过将区间分解，可以在O(logn)的复杂度下解决RMQ问题、单点/区间修改问题，通过这篇文章记录一下对线段树的学习先手再放一篇博客，线段树，其中的实现还包括了zkw线段树，即非递归的线段树（完全不会），等以后学习一下1.概述线段树将[1,n]的区间分解为若干子区间，通过对子区间的修改/统计来实现对[l,r]区间上的修改和统计由此可见，线段树可行的操作必须符合区间加法符合的例如：区间和——区间和 = 左区间和 + 右区间和区间最值——区间最值 = 最值（左区间最值，右区间最值）最大公因数——区间gcd = gcd左区间 + gcd右区间不符合的例如:区间众数——区间众数无法依靠左右区间众数求出线段树空间对[1,n]的区间，线段树需要的空间大致是 n*4​ 精细的空间其实是 n向上取最接近的$2^k$的值的两倍对[1,10]的线段树分解如上我们可以发现：左儿子坐标是父节点坐标*2​ 右儿子坐标是父节点坐标*2+12.实现这篇文章中利用数组实现常规的递归线段树2.0定义12345#define lson pos&lt;&lt;1 //左儿子坐标 当前节点坐标*2#define rson pos&lt;&lt;1|1 //右儿子坐标 当前节点坐标*2+1const int maxn = 100005; //元素个数int sum[maxn * 4], add[maxn * 4]; //sum求和，add为延迟标记int a[maxn],n; //a为原[1,n]数组定义如上2.1建树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//PushUp函数 更新线段树上每个节点的信息 当前是求区间和void PushUp(int pos)&#123; sum[pos] = sum[lson] + sum[rson];&#125;//PushDown函数 下推延迟标记void PushDown(int pos, int ln, int rn)//ln,rn为左右子树的数量&#123; if(add[pos]) //区间改值 &#123; //标记下推 add[lson] = add[pos]; add[rson] = add[pos]; //修改子节点的sum值 sum[lson] = add[pos]*ln; sum[rson] = add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125; /*if(add[pos]) //区间加减 &#123; //标记下推 add[lson] += add[pos]; add[rson] += add[pos]; //修改子节点的sum值 sum[lson] += add[pos]*ln; sum[rson] += add[pos]*rn; //清楚当前节点标记 add[pos] = 0; &#125;*/&#125;//Build建树void Build(int l, int r, int pos)&#123; if(l == r) //l == r抵达叶节点 &#123; sum[pos] = a[l]; //存储数组 return; &#125; int m = (l + r) &gt;&gt; 1; //向左右递归建树 Build(l, m, lson); //向左递归建树 Build(m + 1, r, rson); //向右递归建树 //向上更新节点信息 PushUp(pos);&#125;2.2点修改按之前那幅图我们可以发现，若我们需要修改[5]的信息，那么我们只需向上每层更新一个节点即可复杂度为O(logn)若令a[L] += C12345678910111213141516171819void UpdatePoint(int L, int C, int l, int r, int pos) //对a[L] += C&#123; if(l == r) &#123; a[pos] += C; return ; &#125; int m = (l + r) &gt;&gt; 1; PushDown(pos, m - l + 1, r - m); if(L &lt;= m) //L在中点左侧，在左侧更新 &#123; UpdatePoint(L,C,l,m,lson); &#125; else //L在中点右侧，在右侧更新 &#123; UpdatePoint(L,C,m+1,r,rson); &#125; PushUp(pos); //当前节点更新&#125;2.3区间修改a[L,R] += C / a[L,R] = C 同时需要改动pushdown1234567891011121314151617181920212223void UpdateInterval(int L, int R,int C,int l, int r, int pos) //对a[L,R] += C，或a[L,R] = C&#123; if(L &lt;= l &amp;&amp; r &lt;= R) //[l,r]区间完全包含在[L,R]区间内 &#123; add[pos] = C; sum[pos] = C*(r-l+1); /*sum[pos] += C*(r-l+1); //区间加减 add[pos] += C;*/ return ; &#125; int m = (l + r) &gt;&gt; 1; PushDown(pos, m - l + 1, r - m); if(L &lt;= m) &#123; UpdateInterval(L,R,C,l,m,lson); &#125; if(R &gt; m) &#123; UpdateInterval(L,R,C,m+1,r,rson); &#125; PushUp(pos);&#125;2.4区间查询1234567891011121314151617int Query(int L, int R, int l, int r, int pos)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[pos]; &#125; int m = (l + r) &gt;&gt; 1; //下推标记 PushDown(pos, m - l + 1, r - m); //答案 int ans = 0; if(L &lt;= m) ans += Query(L,R,l,m,lson); if(R &gt; m) ans += Query(L,R,m+1,r,rson); return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2019%2F07%2F03%2FKMP-Algorithm%2F</url>
    <content type="text"><![CDATA[​ KMP算法（看毛片算法）是高效的字符串匹配算法，经过两天的学习，利用这篇文章试着写写自己对KMP的理解先手先放一篇优秀的KMP算法博客：KMP1.暴力匹配算法既然要讲字符串匹配，那就从最基础的暴力算法开始讲起：既然暴力，思路自然简单：将模式串P与文本串S进行匹配Ⅰ若成功匹配，即P[j] == S[i]则 i , j 指针++继续向后匹配Ⅱ若失配，即P[j] != S[i]则开始回溯，即i = i - j +1; j = 0;即模式串指针回到开头暴力代码如下：123456789101112131415161718192021222324252627int ViolentMatch(char* s, char* p)&#123; int sLen = strlen(s); int pLen = strlen(p); int i = 0; int j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; if (s[i] == p[j]) &#123; //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++ i++; j++; &#125; else &#123; //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0 i = i - j + 1; j = 0; &#125; &#125; //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 if (j == pLen) return i - j; else return -1;&#125;暴力算法的时间复杂度在最坏情况下是O(n*m)，这样的复杂度显然是不够暴力匹配之所以效率低下是由于在失配的情况下，需要将模式串指针指向开头，文本串指针指向下一个字符而若是我们仅仅只需要回溯 j 指针而不需要回退 i 指针，这样的算法显然更高效，即KMP算法2.KMP算法2.1定义Knuth-Morris-Pratt 字符串查找算法，简称”看毛片算法“，哦不，“KMP算法”，相比于暴力匹配，KMP算法可以在线性复杂度内完成查找模式串P在文本串S中出现的位置。KMP算法的具体流程如下：构造next[]表，辅助匹配的过程 （重要）开始匹配过程：假设模式串匹配到 j 指针，而文本串匹配到 i 指针若j == -1或当前字符串匹配成功，即P[j] == S[i],则i++; j++;继续下一个字符的匹配若j != -1或当前字符失配，即P[j] != S[i]则令j = next[j]即模式串P相对于文本串向右移动j - next[j]位next[]表的含义是：next[j]代表了在 j 字符前该字符串最大的公共前缀后缀因此当字符串失配时，模式串不需要直接跳到串头，而是跳到next[j]的位置，当next[j] == 0 or -1时，模式串才跳到串的开头则KMP算法的主体部分算法如下：12345678910111213141516171819202122int KMP(char *s,char *p)&#123; int slen = strlen(s); int plen = strlen(p); int i = 0; int j = 0; while(i &lt; slen &amp;&amp; j &lt; plen) &#123; if(j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if(j == plen) return i-j; else return -1;&#125;2.2构造next[]表next[]表实质就是最大公共前后缀的长度2.2.1 next[0] = -1next[]表第一项取值需要我们特殊对待，按邓俊辉老师的数据结构中所讲，可以理解为在任一模式串的 -1 位置处有一假想的哨兵，其可与任意字符相匹配，因此当失配至 j = 0 时，即可认为其实在 -1 的位置上是匹配成功的，因此可以直接i++; j++;2.2.2 递推next[j+1]当我们知道了next[0…j]时，如何确认next[j+1]呢？令k = next[j]，因为 next[j] 指的是在 j 这个字符前最长的公共前后缀长度，所以 next[j] 处的字符即为最长公共前缀的下一项，而 j 处的字符是最后一个字符同时也是最长公共后缀下一个的字符，因此只需比对 next[j] 和 j 处的字符关系即可我们可以分两种情况进行讨论：若P[j] == P[k]则可知在 j 这个位置上是有前缀与 j 处的字符相匹配的那么我们可知next[j+1] = next[j] + 1 = k + 1若P[j] != P[k]则最长公共前缀的下一项与最长公共后缀的下一项是不匹配的，这个时候我们需要继续寻找下一项可能与最后一个字符构成公共前后缀的字符即继续赋值为k = next[k]，若仍然不匹配则k = next[next[k]]直到匹配成功或k = -1 为止所以构造next[]表的代码如下：12345678910111213141516171819void getNext(char *p,int next[])&#123; int plen = strlen(p); next[0] = -1; int j = 0; int k = -1; //用 j 表示后缀 用 k 表示前缀 while(j &lt; plen) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125;&#125;构造完成next[]表后，KMP算法就完成了，只需要依靠next[]表，我们就可以很快的将两个串进行匹配2.3时间复杂度分析KMP算法中假设文本串长度为n，模式串长度为m则匹配过程中复杂度为O(n)，构造next[]表的复杂度为O(m)，因此KMP算法的整体复杂度为O(n+m)可以看出KMP算法是线性的复杂度3.KMP算法改进尽管KMP算法已经将时间复杂度优化了许多，但是在某些特殊情况下，KMP算法有其不可避免的短板，将导致其与暴力匹配算法没什么差别例如：文本串为abacababc​ 模式串为abab那么我们可以写出模式串的next[]表为abab-1001当我们开始匹配后，成功匹配了前3个字符，而将失配于最后一个字符b此时由于next[3] = 1，我们将跳到P[2]上，而P[2]仍然为b，因此必然又将失配，这是由于b已经失配过了，若仍然是b字符则必然失配。那么问题出在哪呢？问题出现在，我们不该将 p[j] == p[next[j]]因为当p[j] != s[i]时，我们的下一步将会用p[next[j]]与s[i]进行匹配，然而在上一步中，我们已经知道，p[j] == p[next[j]]而p[j] != s[i]因此下一步也就必然失配，所以我们在构造next[]表时就需要把这种情况考虑在内即若是出现了p[j] = p[next[j]]这种情况，我们可以直接使next[j] = next[next[j]]因此改进后的next[]表构造代码如下：1234567891011121314151617181920212223242526void getNext(char *p,int next[])&#123; int plen = strlen(p); next[0] = -1; int j = 0; int k = -1; //用 j 表示后缀 用 k 表示前缀 while(j &lt; plen) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; if(p[k] == p[j]) &#123; next[j] = next[k]; &#125; else &#123; next[j] = k; &#125; &#125; else &#123; k = next[k]; &#125; &#125;&#125;通过改进之后我们继续来看前面那个例子可以发现模式串的next[]表如下abab-10-10因此在p[3]失配时，将会直接跳到p[0]进行匹配而不再匹配p[1]这个必然失配的字符4.完整KMP算法（模板）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void getNext(char *p,int next[]) //构造next[]表&#123; int plen = strlen(p); next[0] = -1; int j = 0; int k = -1; //用 j 表示后缀 用 k 表示前缀 while(j &lt; plen - 1) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; if(p[k] == p[j]) &#123; next[j] = next[k]; &#125; else &#123; next[j] = k; &#125; &#125; else &#123; k = next[k]; &#125; &#125;&#125;int KMP(char *s,char *p) //KMP算法主体部分&#123; int slen = strlen(s); int plen = strlen(p); int i = 0; int j = 0; while(i &lt; slen &amp;&amp; j &lt; plen) &#123; if(j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if(j == plen) return i-j; //返回模式串在文本串中出现的为止 else return -1; //模式串与文本串失配&#125;5.HDU1686既然学完了KMP算法，做一道模板题练练手 VJ传送门5.1题意求模式串在待匹配串中的出现次数5.2输入第一行是一个数字T，表明测试数据组数。之后每组数据都有两行：第一行为模式串，长度不大于10,000；第二行为待匹配串，长度不大于1,000,000。（所有字符串只由大写字母组成）5.3输出每组数据输出一行结果5.4Input1234567894ABCDABCDSOSSOSOSOSCDCDCDCCDCKMPSOEASY5.5Output123413005.6题解这道题唯一需要考虑的是当匹配成功之后，如何继续向下匹配可以这样理解，在匹配成功，ans++后，可以认为在当前位置上失配，因此只需继续j = next[j]即可同时通过这道题发现，原来next[]数组不能直接声明为next5.7AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e4 + 5;char p[maxn],s[1000005];int t;int next1[maxn];void getNext()&#123; int plen = strlen(p); int j = 0, k = -1; next1[0] = -1; while(j &lt; plen) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; next1[j] = k; &#125; else k = next1[k]; &#125;&#125;int KMP(int ans)&#123; int plen = strlen(p); int slen = strlen(s); int i = 0, j = 0; while(i &lt; slen) &#123; if(j == -1 || s[i] == p[j]) &#123; ++i; ++j; &#125; else j = next1[j]; if(j == plen) &#123; ans++; j = next1[j]; &#125; &#125; return ans;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; scanf("%s%s",p,s); memset(next1,0,sizeof(next1)); int ans = 0; getNext(); ans = KMP(ans); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开 & 康托展开逆运算]]></title>
    <url>%2F2019%2F06%2F30%2Fkangtuo%2F</url>
    <content type="text"><![CDATA[康托展开求当前排列是全排列中第几个排列 &amp; 康托展开逆运算求第k个排列康托展开是双射的1、康托展开康托展开即序列到自然数的映射例1：求4132是第几个排列？第一个数是4：比4小且未使用过的数有3个，因此x_{0}=3·(4-1)!=3·3·2·1·=18第二个数是1：比1小且未使用过的数有0个，因此x_{1}=0第三个数是3：比3小且未使用过的数有1个，因此x_{2}=1·(4-3)!=1最后一个数可以不计算，因此求和可得 $ans=19+1=20$因此4132是第20个排列例2：求45231是第几个排列？$ans = 3·(5-1)! + 3·(5-2)!+1·(5-3)!+1·(5-4)!+1=94$因此45231是第94个排列康托展开代码实现:12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int a[10]; //存排列int n; //排列长度bool vis[10]; //是否用过int ans; //答案int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; int cnt = 0; int c = 1, m = 1; //阶乘 for(int j=i+1;j&lt;n;j++) &#123; if(a[i]&gt;a[j]) cnt++; m*=c;c++; &#125; ans += cnt * m; &#125; ans++; cout&lt;&lt;ans&lt;&lt;endl;&#125;2、逆康托展开康托展开逆运算即自然数到序列的映射例1：在1~5的全排列中，求第96个排列设排列为$x_{1}x_{2}x_{3}x_{4}x_{5}$则$x_{1}x_{2}x_{3}x_{4}x_{5}$前有95个排列对$x_{1}$:$95/(n-1)!=95/24=3$即有3个比$x_{1}$小的数，$∴x_{1}=4$$ 95 = 95 - 3\times24 = 23$对$x_{2}$:$23/(n-1)!=23/6= 3$即有3个比$x_{2}$小的数，$∴x_{2}=5$$ 23 = 23 - 3\times6 = 5$对$x_{3}$:$5/(n-1)!=5/2= 2$即有2个比$x_{3}$小的数，$∴x_{2}=3$$ 5 = 5 - 2\times2 = 1$对$x_{4}$:$1/(n-1)!=1/1= 1$即有1个比$x_{4}$小的数，$∴x_{4}=2$$∴x_{5}=1$因此这个数是45321逆康托展开代码实现：123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int fac[] = &#123;1,1,2,6,24,120,720,5040,40320,362880&#125;;//阶乘vector&lt;int&gt; v; //存放可选数vector&lt;int&gt; a; //存放排列int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) v.push_back(i); int num; cin&gt;&gt;num; num--; for(int i=n;i&gt;=1;i--) &#123; int r = num % fac[i-1]; int c = num / fac[i-1]; num = r; sort(v.begin(),v.end()); a.push_back(v[c]); v.erase(v.begin()+c); &#125; vector&lt;int&gt;::iterator it; for(it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;' ';&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP——Piggy-Bank POJ1384]]></title>
    <url>%2F2019%2F04%2F11%2Fdp-completebag1%2F</url>
    <content type="text"><![CDATA[Piggy-BankProblem DescriptionBefore ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams.OutputPrint exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”.Sample Input12345678910111213310 11021 130 5010 11021 150 301 6210 320 4Sample Output123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible.思路完全背包问题，只不过与正常完全背包不同点在于，求的是背包装满的情况下的最小值注意点①背包需要恰好完全装满，因此在数组初始化时要有所注意注意点②求的是背包中的价值最小值，在初始化与dp循环中要注意代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cmath&gt;#define maxn 10005#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;int E,F;int N;int v[maxn],w[maxn];int dp[maxn];int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; memset(dp,INF,sizeof(dp)); //恰好完全装满，同时求最小值，初始化为INF dp[0]=0; cin&gt;&gt;E&gt;&gt;F; int W=F-E; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]; &#125; for(int i=0;i&lt;N;i++) &#123; for(int j=w[i];j&lt;=W;j++) &#123; dp[j]=min(dp[j],dp[j-w[i]]+v[i]); //求最小值，用min &#125; &#125; if(dp[W]==INF) cout&lt;&lt;"This is impossible."&lt;&lt;endl; else cout&lt;&lt;"The minimum amount of money in the piggy-bank is "&lt;&lt;dp[W]&lt;&lt;"."&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP——HD2602 01背包 两种DP写法]]></title>
    <url>%2F2019%2F04%2F10%2Fdp-01pack%2F</url>
    <content type="text"><![CDATA[Bone CollectorProblem DescriptionMany years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?InputThe first line contain a integer T , the number of cases.Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.OutputOne integer per line representing the maximum of the total value (this number will be less than 231).Sample Input123415 101 2 3 4 55 4 3 2 1Sample Output114思路DP01背包问题，利用DP划为子问题解决Ⅰ二维数组有以下递推式dp[0][j]=0dp[i+1][j]= \begin{cases} dp[i][j]& j]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归、记忆化搜索——从斐波那契数列出发]]></title>
    <url>%2F2019%2F04%2F10%2Fmemorysearch1%2F</url>
    <content type="text"><![CDATA[斐波那契数列求和这是一个熟悉的问题，对于这个问题有许多做法Ⅰ递归即使用以下代码123456789101112131415161718// 递归#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll fib(int n)&#123; if(n&lt;=2) return 1; else return fib(n-1)+fib(n-2);&#125;int main()&#123; ll res=fib(45); cout&lt;&lt;res&lt;&lt;endl; cout&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;endl;&#125;递归是最简单好写的代码，然而在计算的过程中，对于斐波那契数列中的许多项递归会进行多次的重复计算，当计算的前n项和越来越大时，计算的时间也就越来越长，对于计算45项和即需要5~6s的时间进行计算，这个效率可以说是十分低下的Ⅱ记忆化搜索记忆化搜索使用以下代码123456789101112131415161718192021//记忆化搜索#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[5000];ll fib(int n)&#123; if(dp[n]&gt;0) return dp[n]; else if(n&lt;=2) return 1; else return dp[n]=fib(n-1)+fib(n-2);&#125;int main()&#123; memset(dp,-1,sizeof(dp)); ll res=fib(50); cout&lt;&lt;res&lt;&lt;endl; cout&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;endl;&#125;与递归的不同之处是，记忆化搜索单独开辟了一个数组用于存储之前计算过的数值，当某个数已经被计算过之后就可以直接return，效率比起递归来说提升了许多，即便是几千也不到1s重点是在函数里最后1return dp[n]=fib(n-1)+fib(n-2)将每一项的值直接存入数组当然记忆化搜索并不是最优的方法，需要开辟数组来存储数据，但起码在时间上，记忆化搜索已经做到了足够优秀Ⅲ动态规划DP利用DP来计算斐波那契数列可以做到在空间上也是最优的方程即为dp[n]=dp[n-1]+dp[n-2]dp[0]=1dp[1]=1]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心——Fence Repair POJ3253]]></title>
    <url>%2F2019%2F04%2F09%2Fgreedyalgorithm-POJ3253%2F</url>
    <content type="text"><![CDATA[Fence Repair POJ3253DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the Nplanks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.InputLine 1: One integer N, the number of planksLines 2..N+1: Each line contains a single integer describing the length of a needed plankOutputLine 1: One integer: the minimum amount of money he must spend to make N-1 cutsSample Input12343858Sample Output134思路贪心选择所有数据中最短的两块，计算和，再将他们的和放入队列里，循环操作直到队列中元素＜2错解12345678sort(wood,wood+n); ll ans=0,now; for(int i=1;i&lt;n;i++) &#123; now=wood[i-1]+wood[i]; ans+=now; wood[i]=now; &#125;利用上述代码循环贪心，会T！正解利用优先队列存储目标学习了vector, greater> que;```创建优先队列12345678910111213141516171819202122232425262728293031323334**优先队列其实是完全二叉树，与队列关系不大，pop的是队列中优先级最高的数据**## 代码```c++#include &lt;bits/stdc++.h&gt;#define maxn 50001typedef long long ll;using namespace std;int main()&#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que; //创建优先队列（优先级为从小到大） ll n,wood[maxn],temp,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;temp; que.push(temp); //数据进队列 &#125; while(que.size()&gt;1) &#123; ll l1=que.top(); //队列中最小的数据 que.pop(); ll l2=que.top(); //队列中次小的数据 que.pop(); ll t=l1+l2; ans+=t; que.push(t); //将数据进队列 &#125; cout&lt;&lt;ans&lt;&lt;endl; cout&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心——Saruman's Army POJ3069]]></title>
    <url>%2F2019%2F04%2F09%2Fgreedyalgorithm4-POJ3069%2F</url>
    <content type="text"><![CDATA[Saruman’s ArmyDescriptionSaruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army (i.e., palantirs are not allowed to “free float” in mid-air). Help Saruman take control of Middle Earth by determining the minimum number of palantirs needed for Saruman to ensure that each of his minions is within R units of some palantir.InputThe input test file will contain multiple cases. Each test case begins with a single line containing an integer R, the maximum effective range of all palantirs (where 0 ≤ R ≤ 1000), and an integer n, the number of troops in Saruman’s army (where 1 ≤ n ≤ 1000). The next line contains n integers, indicating the positions x1, …, xn of each troop (where 0 ≤ xi ≤ 1000). The end-of-file is marked by a test case with R = n = −1.OutputFor each test case, print a single integer indicating the minimum number of palantirs needed.Sample Input123450 310 20 2010 770 30 1 7 15 20 50-1 -1Sample Output1224思路Ⅰ起初我的贪心思路是直接选择最左边的点开始向右搜索，找到的每一个与初始点相距＞r的点，作为下一个被标记的点继续开始搜索，然而在第二个样例中发现，这样的贪心思路是错误的，这样贪心的结果是5，而最后的答案是4Ⅱ因此正确的思路是从第一个点开始，向右寻找到第一个与其相距＞r的点，这个点左边的点即为第一个需要被标记的点，再从这个点出发，寻找第一个和这个点相距＞r的点，这个点即为下一次贪心的起点，反复下去，直到寻找完所有的点代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#define maxn 1001#define INF 0x3f3f3f3fusing namespace std;bool cmp(int a,int b)&#123; return a&lt;b;&#125;int main()&#123; int n,r,x[maxn]; while(cin&gt;&gt;r&gt;&gt;n &amp;&amp; n!=-1 &amp;&amp; r!=-1) &#123; for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i]; sort(x,x+n,cmp); int i=0,res=0; while(i&lt;n) &#123; int s=x[i++]; //没有被覆盖的最左的点 while(x[i]-s&lt;=r &amp;&amp; i&lt;n) //一直向右直到找到与s相距＞r的点 &#123; i++; &#125; int l=x[i-1]; //则被标记的点即x[i-1] while(x[i]-l&lt;=r &amp;&amp; i&lt;n) //一直向右直到找到与l相距＞r的点 &#123; i++; &#125; res++; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心——Best Cow Line POJ3617]]></title>
    <url>%2F2019%2F04%2F08%2Fgreedyalgorithm3-poj3617%2F</url>
    <content type="text"><![CDATA[Best Cow Line 传送门DescriptionFJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.Input* Line 1: A single integer: N* Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original lineOutputThe least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line.Sample Input12345676ACDBCBSample Output1ABCBCD思路直接贪心选择字符串首尾中字典序较小的那一个注意点①当前后字符相同时，需要比较下一对字符的字典序关系白书给出以下巧妙的循环结构加以比较之后的字符关系，而不是使用递归进行比较1234567891011bool w=0;for(int i=0;i&lt;=b-a;i++) &#123; if(S[a+i]&lt;S[b-i]) break; else if(S[a+i]&gt;S[b-i]) &#123; w=1; break; &#125; &#125;②输出每80个字符需要换行代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 2001#define INF 0x3f3f3f3fusing namespace std;char S[maxn],ans[maxn];int n;int main()&#123; while(cin&gt;&gt;n) &#123; memset(S,'\0',sizeof(S)); //其实并没有什么卵用 memset(ans,'\0',sizeof(ans)); int j=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;S[i]; &#125; int a=0,b=n-1; //字符串的左端与右端 while(a&lt;=b) &#123; bool w=0; //w=0时选择左端；w=1时选择右端 for(int i=0;i&lt;=b-a;i++) &#123; if(S[a+i]&lt;S[b-i]) //若左端小于右端 直接break break; else if(S[a+i]&gt;S[b-i]) //若右端小于左端，使w=1，break &#123; //当左端等于右端时，不满足两个if进入下一次循环 w=1; //同时下一次循环不改变a,b的值，但可以比较下一对字符 break; &#125; &#125; if(w) ans[j++]=S[b--]; else ans[j++]=S[a++]; &#125; for(int i=0;ans[i]!='\0';i++) &#123; if(i%80==0 &amp;&amp; i!=0) cout&lt;&lt;endl; cout&lt;&lt;ans[i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心——区间调度问题 白书P40]]></title>
    <url>%2F2019%2F04%2F08%2Fgreedyalgorithm2%2F</url>
    <content type="text"><![CDATA[区间调度问题问题描述有n项工作，每项工作分别在si开始，ti结束。对每项工作，你都可以选择参加或不参加，但选择了参加某项工作就必须至始至终参加全程参与，即参与工作的时间段不能有重叠(即使开始的时间和结束的时间重叠都不行)。限制条件1≤n≤1000001≤si≤ti≤109样例输入12351 2 4 6 83 5 7 9 10输出13思路利用贪心，贪心在可选的工作中，每次都选区结束时间最早的工作对数据先按照结束时间的早晚进行排序，每次选择在可选范围内结束时间最早的工作证明结束时间越早则之后可选的工作也就越多——对算法的直观解释Ⅰ与其他方案相比，该算法选择在选取相同数量的更早开始的工作时，其最终结束时间不会比其他方案更晚Ⅱ因此，不存在选取更多工作的选择方案代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define maxn 100001#define INF 0x3f3f3f3fusing namespace std;int n,res=0;struct work&#123; int s; int t;&#125;job[maxn];bool cmp(work a,work b)&#123; return a.t&lt;b.t;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;job[i].s; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;job[i].t; &#125; sort(job,job+n,cmp); //按照工作结束的时间进行排序 int t=0; for(int i=0;i&lt;n;i++) &#123; if(t&lt;job[i].s) //若t小于第i项工作开始的时间，则该工作可选 &#123; res++; t=job[i].t; //令t等于第i项工作结束的时间，即可选范围内结束最早的工作 &#125; &#125; cout&lt;&lt;res&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬币问题（贪心）——白书p39]]></title>
    <url>%2F2019%2F04%2F07%2Fgreedymethod1%2F</url>
    <content type="text"><![CDATA[硬币问题（贪心解法）题目描述有1元，5元，10元，50元，100元，500元的硬币，各C1,C5,C10,C50,C100,C500C1,C5,C10,C50,C100,C500枚。现在要用来支付A元，最少需要各种硬币多少。假定本题至少存在一种支付方案。样例输入C1=3 , C5=2 , C10=1 , C50=3 , C100=0 , C500=2A = 620样例输出6(500的1个，50的2个，10的1个，5元的2个，合计6个)思路优先选择面额最大的硬币代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int money[6]=&#123;1,5,10,50,100,500&#125;; int c[6]; int A; for(int i=0;i&lt;6;i++) &#123; cin&gt;&gt;c[i]; &#125; cin&gt;&gt;A; int ans=0; for(int i=5;i&gt;=0;i--) &#123; int temp=min(A/money[i],c[i]); //选择尽可能多的大面额 A-=temp*money[i]; ans+=temp; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索dfs——Oil Deposits ShuOJ4]]></title>
    <url>%2F2019%2F04%2F06%2Fdfs-shuoj4%2F</url>
    <content type="text"><![CDATA[ShuOJ4传送门题目The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits.GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that dividesthe land into numerous square plots. It then analyzes each plot separately, using sensing equipment todetermine whether or not the plot contains oil.A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of thesame oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is todetermine how many different oil deposits are contained in a grid.InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the numberof rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input;otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not countingthe end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing theabsence of oil, or ‘@’, representing an oil pocket.OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the sameoil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not containmore than 100 pockets.Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0Sample Output12340122思路dfs遍历全图，题意、思路与POJ2386相同，遍历全图，找到任一为@的点进行dfs搜索附近所有和它同一组的@代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define maxn 105using namespace std;int n,m;char oil[maxn][maxn];bool vis[maxn][maxn];int dx[]=&#123;1,1,1,0,0,-1,-1,-1&#125;;int dy[]=&#123;1,0,-1,1,-1,1,0,-1&#125;;void dfs(int x,int y)&#123; if(x&lt;0 || y&lt;0 || x&gt;=n || y&gt;=m) return ; if(vis[x][y] || oil[x][y]=='*') return ; vis[x][y]=1; for(int i=0;i&lt;8;i++) dfs(x+dx[i],y+dy[i]);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n &amp;&amp; m) //注意输入 &#123; memset(vis,0,sizeof(vis)); int res=0; //注意结果的清零 for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;oil[i][j]; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(oil[i][j]=='@' &amp;&amp; !vis[i][j]) &#123; dfs(i,j); res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索bfs——迷宫问题 POJ3984]]></title>
    <url>%2F2019%2F04%2F06%2Fbfs2poj3984%2F</url>
    <content type="text"><![CDATA[迷宫问题POJ3984定义一个二维数组：12345678910111213int maze[5][5] = &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;;它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。Input一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。Output左上角到右下角的最短路径，格式如样例所示Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4)思路​ 利用bfs解决最短路径问题，这道题bfs的不同之处在于需要记忆之前所走的路，因此在node中需要多加一个数据结构，利用l[40]数组来存储在bfs过程中走的路​ 通过next[cur.step]=i来获取这一步是如何走的，cur.step存储这是第几步，i用来存储方向，通过之前预设的dx[],dy[]两个数组在最后输出的时候为每一步加上方向。代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define maxn 105#define INF 0x3f3f3f3fusing namespace std;int maze[6][6];int dx[]=&#123;1,0,0,-1&#125;;int dy[]=&#123;0,1,-1,0&#125;;bool vis[6][6];struct node&#123; int x,y,step; int l[40];&#125;;bool can_vis(int x,int y)&#123; if(x&lt;0 || y&lt;0 || x&gt;=5 || y&gt;=5) return false; if(vis[x][y] || maze[x][y]) return false; return true;&#125;node bfs()&#123; node cur,next; cur.x=0;cur.y=0;cur.step=0; memset(cur.l,0,sizeof(cur.l)); memset(next.l,0,sizeof(next.l)); queue&lt;node&gt; q; q.push(cur); while(!q.empty()) &#123; cur=q.front(); q.pop(); if(cur.x==4 &amp;&amp; cur.y==4) return cur; for(int i=0;i&lt;4;i++) &#123; next=cur; next.x=cur.x+dx[i]; next.y=cur.y+dy[i]; if(!can_vis(next.x,next.y)) continue; next.step=cur.step+1; next.l[cur.step]=i; q.push(next); &#125; &#125;&#125;int main()&#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;5;i++) &#123; for(int j=0;j&lt;5;j++) &#123; cin&gt;&gt;maze[i][j]; &#125; &#125; node ans=bfs(); int x=0,y=0; for(int i=0;i&lt;=ans.step;i++) &#123; cout&lt;&lt;'('&lt;&lt;x&lt;&lt;", "&lt;&lt;y&lt;&lt;')'&lt;&lt;endl; x+=dx[ans.l[i]]; y+=dy[ans.l[i]]; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next_permutation]]></title>
    <url>%2F2019%2F04%2F06%2Fnext-permutation%2F</url>
    <content type="text"><![CDATA[利用next_permutation函数对n个元素进行n!种不同的全排列，按字典序生成排序代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char x[4]=&#123;'a','b','c','d'&#125;; int res=0; do &#123; for(int i=0;i&lt;4;i++) cout&lt;&lt;x[i]&lt;&lt;" "; cout&lt;&lt;endl; res++; &#125;while(next_permutation(x,x+4)); cout&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;endl; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;输出结果1234567891011121314151617181920212223242526a b c da b d ca c b da c d ba d b ca d c bb a c db a d cb c a db c d ab d a cb d c ac a b dc a d bc b a dc b d ac d a bc d b ad a b cd a c bd b a cd b c ad c a bd c b a0.01824]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>全排列</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索dfs——Lake Counting POJ2386]]></title>
    <url>%2F2019%2F04%2F06%2Fdfs1%2F</url>
    <content type="text"><![CDATA[POJ No.2386 Lake Counting传送门题意有一个大小为NM的园子，雨后积起了水。八连通的积水被认为是连接在一起的。请求出园子里总共有多少水洼？（八连通指的是下图中相对W的 部分）123****W****限制条件N，M≤100输入123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W.输出13当需要对所有状态进行遍历时，首先选择dfs代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define INF 0x3f3f3f3f#define maxn 105using namespace std;int N,M;char w[maxn][maxn];bool vis[maxn][maxn];int dx[8]=&#123;1,1,1,0,0,-1,-1,-1&#125;;int dy[8]=&#123;1,0,-1,1,-1,1,0,-1&#125;;int res=0;void dfs(int x,int y)&#123; if(x&lt;0 || y&lt;0 || x&gt;=N || y&gt;=M) return ; if(w[x][y]=='.' || vis[x][y]) return ; vis[x][y]=true; for(int i=0;i&lt;8;i++) dfs(x+dx[i],y+dy[i]);&#125;int main()&#123; cin&gt;&gt;N&gt;&gt;M; for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;M;j++) &#123; cin&gt;&gt;w[i][j]; &#125; &#125; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;M;j++) &#123; if(w[i][j]=='W' &amp;&amp; !vis[i][j]) &#123; dfs(i,j); res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm 搜索bfs——迷宫的最短路径 白书p34]]></title>
    <url>%2F2019%2F04%2F06%2Fbfs1%2F</url>
    <content type="text"><![CDATA[迷宫的最短路径给定一个大小为N×M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动。请求出从起点到终点所需的最小步数。请注意，本题假定从起点一定可以移动到终点。（N,M≤100）（’#’, ‘.’ , ‘S’, ‘G’分别表示墙壁、通道、起点和终点）输入1234567891011121310 10#S######.#......#..#.#.##.##.#.#........##.##.####....#....#.#######.#....#......####.###.....#...G#输出122思路最简单的bfs问题，求最短路问题一般采用bfs代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define maxn 105using namespace std;int N,M; //迷宫大小int dx[4]=&#123;1,0,0,-1&#125;; //x,y方向int dy[4]=&#123;0,1,-1,0&#125;;char maze[maxn][maxn]; //存储迷宫状态bool vis[maxn][maxn];int sx,sy,ex,ey; //起点 终点struct node&#123; int x,y; int step;&#125;;bool can_vis(int x,int y)&#123; if(x&lt;0 || y&lt;0 || x&gt;=N || y&gt;=M) return false; if(vis[x][y]) return false; if(maze[x][y]=='#') return false; return true;&#125;int bfs()&#123; queue&lt;node&gt; q; node cur,next; cur.x=sx;cur.y=sy;cur.step=0; q.push(cur); while(!q.empty()) &#123; cur=q.front(); q.pop(); if(cur.x==ex &amp;&amp; cur.y==ey) return cur.step; for(int i=0;i&lt;4;i++) &#123; next=cur; next.x=cur.x+dx[i]; next.y=cur.y+dy[i]; if(!can_vis(next.x,next.y)) continue; vis[next.x][next.y]=true; next.step=cur.step+1; q.push(next); &#125; &#125;&#125;int main()&#123; memset(vis,false,sizeof(vis)); cin&gt;&gt;N&gt;&gt;M; for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;M;j++) &#123; cin&gt;&gt;maze[i][j]; if(maze[i][j]=='S') &#123; sx=i;sy=j; &#125; if(maze[i][j]=='G') &#123; ex=i;ey=j; &#125; &#125; &#125; int ans=bfs(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm入门二分(1)——CF371C Hamburgers]]></title>
    <url>%2F2019%2F01%2F21%2F2f-1%2F</url>
    <content type="text"><![CDATA[题目Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite “Le Hamburger de Polycarpus” as a string of letters ‘B’ (bread), ‘S’ (sausage) и ‘C’ (cheese). The ingredients in the recipe go from bottom to top, for example, recipe “ВSCBS” represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again.Polycarpus has nb pieces of bread, ns pieces of sausage and nc pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are pb rubles for a piece of bread, ps for a piece of sausage and pc for a piece of cheese.Polycarpus has r rubles and he is ready to shop on them. What maximum number of hamburgers can he cook? You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient.InputThe first line of the input contains a non-empty string that describes the recipe of “Le Hamburger de Polycarpus”. The length of the string doesn’t exceed 100, the string contains only letters ‘B’ (uppercase English B), ‘S’ (uppercase English S) and ‘C’ (uppercase English C).The second line contains three integers nb, ns, nc (1 ≤ nb, s, nc ≤ 100) — the number of the pieces of bread, sausage and cheese on Polycarpus’ kitchen. The third line contains three integers pb, ps, pc(1 ≤ pb , ps , pc ≤ 100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1 ≤ r ≤ 1012) — the number of rubles Polycarpus has.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.OutputPrint the maximum number of hamburgers Polycarpus can make. If he can’t make any hamburger, print 0.ExamplesInput1234BBBSSC6 4 11 2 34Output12Input1234BBC1 10 11 10 121Output17Input1234BSC1 1 11 1 31000000000000Output1200000000001题意拥有r钱，做一个汉堡需要nb , ns , nc的原材料，已拥有s,b,c材料，去商店购买s,b,c需要pb , ps , pc钱（商店可提供原料无限），求最多可做多少个汉堡。思路先读入字符串，对每种需要的材料++用二分暴力求值，res为最多能做多少汉堡，开始进行二分求解对check()，做mid个汉堡需要原材料多少，拥有的材料不够则去商店购买，求购买一共需要sum将sum与r进行对比1234if(sum&lt;=r) //需要的钱少于拥有的钱 即可以做更多汉堡 l=mid;else r=mid;代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;typedef long long ll;ll needb,needs,needc;ll nb,ns,nc;ll pb,ps,pc;ll have,mid,l=0,r=1000000000000000;bool check(ll a)&#123; ll sum=0; if(needb&amp;&amp;a*needb&gt;nb) sum+=(a*needb-nb)*pb; if(needs&amp;&amp;a*needs&gt;ns) sum+=(a*needs-ns)*ps; if(needc&amp;&amp;a*needc&gt;nc) sum+=(a*needc-nc)*pc; if(sum&lt;=have) return 1; else return 0;&#125;int main()&#123; string str; cin&gt;&gt;str; for(int i=0;i&lt;str.length();i++) &#123; if(str[i]=='B') needb++; else if(str[i]=='S') needs++; else needc++; &#125; cin&gt;&gt;nb&gt;&gt;ns&gt;&gt;nc; cin&gt;&gt;pb&gt;&gt;ps&gt;&gt;pc; cin&gt;&gt;have; while(r&gt;=l) &#123; mid=(r+l)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; if(check(r)) cout&lt;&lt;r&lt;&lt;endl; else cout&lt;&lt;l&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm入门dp(2)——CF189A.Cut Ribbon完全背包（装满）]]></title>
    <url>%2F2019%2F01%2F21%2Fdp2%2F</url>
    <content type="text"><![CDATA[题目Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:After the cutting each ribbon piece should have length a, b or c.After the cutting the number of ribbon pieces should be maximum.Help Polycarpus and find the number of ribbon pieces after the required cutting.InputThe first line contains four space-separated integers n, a, b and c (1 ≤ n, a, b, c ≤ 4000) — the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.OutputPrint a single number — the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.Examplesinput5 5 3 2output2input7 5 5 2output2NoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.题意一根带子可以剪成abc三种长度，尽可能剪成更多份数。思路完全背包问题，将带子的长度看作背包的容量，abc则是可以放入背包的物品，他们的价值都为1，代价分别为abc，同时背包需要装满（划重点）。12memset(dp,-9999,sizeof(dp))；dp[0]=0;在dbg过程中发现， 若对数组全部赋初值0，则最后的结果是错误的，问题就出在数组的初始化上。主要是由于背包状态的不同，对初始值的要求有所不同，对这道题来说，显然剪成的几段带子和等于带子总长，也就是需要将背包装满的状态。对于不需要装满的背包，可以说任意情况都是有解的，其中最简单的情况就是背包价值为0，即dp(0..n)=0对于需要装满的背包，最初仅仅在背包容量为0时是成立的，即dp[0]=0，而对于dp(1…n)的状态是未知的，需要从已知的状态推导出来理解了装满问题后， 就剩下完全背包dp部分即for(cost...n) dp[i]=max(dp[i],dp[i-cost]+1)题中cost即abc的长度，每条带子的价值为1代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[3]=&#123;0&#125;;int dp[10000];int main()&#123; int n; cin&gt;&gt;n&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]; memset(dp,-9999,sizeof(dp)); //背包装满特殊初始化 dp[0]=0; for(int i=0;i&lt;3;i++) &#123; for(int j=a[i];j&lt;=n;j++) &#123; dp[j]=max(dp[j],dp[j-a[i]]+1); &#125; &#125; cout&lt;&lt;dp[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm入门dp(1)——HD2084数塔]]></title>
    <url>%2F2019%2F01%2F21%2Facm-dp1%2F</url>
    <content type="text"><![CDATA[12//记录acm入门//dp入门第一天，HD2084解题报告题目HD2084：传送门有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？Input输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。Output对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。Sample Input1573 88 1 02 7 4 44 5 2 6 5Sample Output30思路自底向上递推dp；若要使得输出的最大和，则在自底向上的过程中，每一个节点要取下层两个节点的最大值；即dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+dp[i][j]代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int a[105][105]=&#123;0&#125;;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; for(int i=n-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=n;j++) &#123; a[i][j]+=max(a[i+1][j],a[i+1][j+1]); &#125; &#125; cout&lt;&lt;a[1][1]&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
